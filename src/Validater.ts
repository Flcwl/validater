import Utils from './utils'

export interface StrategyPlugin {
  [key: string]: ValidaterStrategy
}

export interface ValidaterRule {
  name: string
  strategy: any
  message?: string
}

interface ValidateFunc {
  (value: unknown, strategy: any): boolean
}

interface Validator {
  (value: unknown): string | undefined
}

interface ValidaterStrategy {
  validate: ValidateFunc
  message: string
}

interface ValidatorTable {
  [key: string]: Validator
}

interface ErrorTable {
  string?: string
}

enum ValidaterType {
  string = 'string',
  boolean = 'boolean',
  number = 'number',
}

interface ValidaterOptions {
  trim: boolean
  type: ValidaterType
  defaultMessage: string
}

// function parseScheme(scheme: string) {
//   let [ruleName, ruleParam] = scheme.split(':')
//   // contains:$1,$2,$3
//   const funcParams = ruleParam ? ruleParam.split(',') : []
//   // rule.setParams(funcParams);
//   // rules[ruleName] = rule;
//   return funcParams
// }
const getConvert = (type: ValidaterType, trim: boolean) => {
  switch (type) {
    case ValidaterType.number:
      return Number
    case ValidaterType.boolean:
      return Boolean
    default:
      return trim ? (value: unknown) => String(value).trim() : (value: unknown) => String(value)
  }
}
const REGEX_FORMAT = /\/[^\/]|\$(0)/g
const defaultOptions = {
  trim: true,
  type: ValidaterType.string,
  defaultMessage: 'The value is incorrect',
}

/**
 * check if true/false, if false then return msg special field to
 */
class Validater {
  static strategyTable: StrategyPlugin = {} // injected validation strategies
  static defaultOptions: ValidaterOptions = defaultOptions // validation options
  type: ValidaterType // type to convert
  trim: boolean // trim before validating
  convert: (value: unknown) => boolean | string | number // pre process
  defaultMsg: string // global errorMessage
  errorTable: ErrorTable // errorMessage's table
  validatorTable: ValidatorTable // validators generated by rules
  ruleSequence: string[]

  /**
   * @param rules validation rules of user
   * @param options validation options of user
   */
  constructor(rules?: ValidaterRule[], options?: ValidaterOptions) {
    const { trim, type, defaultMessage } = Object.assign({}, options, Validater.defaultOptions)

    this.errorTable = {}
    this.validatorTable = {}
    this.ruleSequence = []
    this.defaultMsg = defaultMessage
    this.convert = getConvert(type, trim)
    this.addRules(rules)
  }

  /**
   * Traverse rules to generate validators
   */
  addRules = (rules?: ValidaterRule[]) => {
    if (Utils.a(rules) === false) {
      console.warn('Warn: Expected an array is not empty for rules.')
      return
    }

    // @ts-ignore
    rules.forEach((rule) => {
      try {
        this.registerValidator(rule)
      } catch (error) {
        console.warn(`Warn: Invalid Rule "${rule.name}" has been remove.`)
      }
    })
  }

  /**
   * Register validators generated based on rules
   */
  registerValidator = (rule: ValidaterRule) => {
    const { name, strategy, message } = rule
    const { defaultMsg, formatMessage, convert } = this
    const validater = Validater.strategyTable[name]
    let validator: Validator

    if (Utils.u(validater)) {
      const error = message || defaultMsg
      validator = (value: unknown) => {
        if (strategy(convert(value)) === false) {
          return formatMessage(error, value)
        }
      }
    } else {
      const { validate, message: defaultRuleMsg } = validater
      const error = message || defaultRuleMsg || defaultMsg
      validator = (value: unknown) => {
        if (validate(convert(value), strategy) === false) {
          return formatMessage(error, value)
        }
      }
    }

    this.validatorTable[name] = validator
    this.ruleSequence.push(name)
  }

  validate = (value: unknown, ruleName?: string): string | void => {
    if (Utils.u(ruleName)) {
      return this.validateOne(value)
    }

    // @ts-ignore
    const validator = this.validatorTable[ruleName]

    if (!validator) {
      throw 'Validator rule not found in register ruleTable.'
    }

    const errorMsg = validator(value)
    if (errorMsg) {
      // @ts-ignore
      this.errorTable[ruleName] = errorMsg
      return errorMsg
    }
  }

  validateOne = (value: unknown): string | void => {
    const { validatorTable, ruleSequence } = this
    for (let i = 0, len = ruleSequence.length; i < len; i++) {
      const ruleName = ruleSequence[i]
      const validator = validatorTable[ruleName]
      const errorMsg = validator(value)

      if (errorMsg) {
        this.errorTable[ruleName] = errorMsg
        return errorMsg
      }
    }
  }

  validateAll = (value: unknown): Validater => {
    const { validatorTable } = this
    for (const ruleName in validatorTable) {
      if (Object.prototype.hasOwnProperty.call(validatorTable, ruleName)) {
        const validator = validatorTable[ruleName]
        const errorMsg = validator(value)
        if (errorMsg) {
          this.errorTable[ruleName] = errorMsg
        }
      }
    }
    return this
  }

  formatMessage = (message: string, value: unknown): string => {
    return message.replace(REGEX_FORMAT, (_, $1) => ($1 ? value : $1))
  }

  hasError = () => {
    return Object.keys(this.errorTable).length > 0
  }

  getError = (ruleName?: string) => {
    return ruleName ? this.errorTable[ruleName] : this.errorTable
  }

  /**
   * Extend validation plugin
   */
  static extend(ruleName: string, validate: ValidateFunc, message = ''): typeof Validater {
    if (Utils.u(Validater.strategyTable[ruleName]) === false) {
      throw `Validator named ${ruleName} already exists.`
    }

    if (Utils.f(validate)) {
      throw 'Validator must be a function'
    }

    Validater.strategyTable[ruleName] = { validate, message }
    return Validater
  }
}

export default Validater
